<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Cherry Markdown ç¼–è¾‘å™¨ç¤ºä¾‹</title>
    <!-- å¼•å…¥Cherry Markdownçš„CSSæ–‡ä»¶ -->
    <link rel="stylesheet" type="text/css" href="/pc/static/cherry-markdown/cherry-markdown.css">
    <script src="/pc/static/js/tailwind.js"></script>
    <!-- å¼•å…¥Font Awesome -->
    <link href="/pc/static/css/fontAwesome.css" rel="stylesheet">
    <link href="/pc/static/css/layui.css" rel="stylesheet">

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 99%;
            font-family: Arial, sans-serif;
        }

        .message-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            justify-content: flex-end;
        }

        .replace-bubble {
            background: #ffeb3b;
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .replace-bubble:hover {
            background: #fdd835;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

        .replace-bubble::before {
            content: "ğŸ”„";
            font-size: 1.1em;
        }

        /* ç¼–è¾‘å™¨å®¹å™¨æ ·å¼ */
        #contain {
            width: 100%;
            height: 96%;
            display: flex;
        }

        /* ç¼–è¾‘å™¨å®¹å™¨æ ·å¼ */
        #main {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }

        #footer {
            width: 100%;
            height: 10%;
            box-sizing: border-box;
        }

        #left-panel {
            /*flex: 1;*/
            width: 100%;
            height: 100%;
            /*padding: 20px;*/
            /*background: #f5f5f5;*/
        }

        .message {
            margin-bottom: 15px;
            max-width: 80%;
            padding: 12px 18px;
            border-radius: 20px;
            animation: fadeIn 0.3s ease-in;
        }

        .user-message {
            background: #e3f2fd;
            margin-left: auto;
        }

        .ai-message {
            background: #fff;
            border: 1px solid #ddd;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .export {
            position: absolute;
            top: 0.5%;
            right: 2%;
            z-index: 999;
        }





        .titleCon {
            position: absolute;
            width: 100%;
            top: 6%;
            z-index: 999;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
        }

        .dividerCon {}

        .editerCon {
            width: 50%;
            font-weight: 600;
            color: #4b5563;
            border-bottom: 1px solid #e2e8f0;
            background-color: #f8fafc;
            padding: 10px;
            border-right: 1px solid #E2E8F0;
        }

        .perviewCon {
            width: 50%;
            font-weight: 600;
            color: #4b5563;
            border-bottom: 1px solid #e2e8f0;
            background-color: #f8fafc;
            padding: 10px;
            border-right: 1px solid #E2E8F0;
        }

        .tip {
            position: absolute;
            margin-left: 54px;
            font-size: 11px;
            color: #4b5563b5;
        }

        .cherry-dropdown {
            z-index: 999 !important;
        }

        .cherry .cherry-editor-title {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            line-height: 40px;
            font-weight: 600;
            color: #4b5563;
            background-color: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            padding-left: 10px;
            box-sizing: border-box;
            z-index: 10;
        }

        .CodeMirror-scroll {
            overflow: scroll !important;
            /* Things will break if this is overridden */
            /* 50px is the magic margin used to hide the element's real scrollbars */
            /* See overflow: hidden in .CodeMirror */
            margin-bottom: -50px;
            margin-right: 0px;
            padding-top: 28px;
            height: 100%;
            outline: none;
            /* Prevent dragging from highlighting the element */
            position: relative;
        }

        .cherry .cm-editor {
            position: relative;
            padding-top: 40px;
        }

        .cherry .cherry-previewer {
            position: relative;
            padding-top: 0px;
        }


        .cherry-previewer .cherry-editor-title {
            position: sticky;
            top: 0;
            z-index: 10;
            background-color: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }

        .cherry-previewer {
            padding-right: 0px !important;
        }
    </style>
</head>

<body>
    <div id="contain">
        <div class="export">
            <button class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded transition-colors"
                onclick="export_word('word')">
                <i class="fa fa-file-word-o mr-2"></i>å¯¼å‡ºword
            </button>
            <button class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded transition-colors"
                onclick="export_pdf('pdf')">
                <i class="fa fa-file-pdf-o mr-2"></i>å¯¼å‡ºpdf
            </button>
            <button class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded transition-colors"
                onclick="export_markdown()">
                <i class="fa fa-copy mr-2"></i>ä¿å­˜markdownæ–‡ä»¶
            </button>
            <button class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded transition-colors"
                onclick="export_txt()">
                <i class="fa fa-file-text mr-2"></i>å¤åˆ¶æ–‡å­—
            </button>
        </div>
        <!-- <div class="tip">å¯å°†å¤§æ¨¡å‹ä¸­çš„å†…å®¹å¤åˆ¶åˆ°æ­¤å¤„è¿›è¡Œç¼–è¾‘</div> -->
        <!-- ç¼–è¾‘å™¨å®¹å™¨ -->
        <div id="left-panel">
            <div id="main">
                <!-- <div class="titleCon">
                    <div class="editerCon">ç¼–è¾‘åŒº</div> -->
                <!-- <div class="dividerCon"></div> -->
                <!-- <div class="perviewCon">é¢„è§ˆåŒº</div>
                </div> -->
                <div id="editor" style="height: 106%;"></div>
            </div>
            <!--        <div id="footer">-->
            <!--            <input type="file" id="fileInput">-->
            <!--            <button id="upload" onclick="startUpload()">ä¸Šä¼ æ–‡ä»¶</button>-->
            <!--            <button onclick="generateMenu()">ç”Ÿæˆç›®å½•</button>-->
            <!--            <button onclick="generateMsg(0)">ç”Ÿæˆå†…å®¹</button>-->
            <!--&lt;!&ndash;            <button onclick="exportWord()">å¯¼å‡ºå†…å®¹</button>&ndash;&gt;-->
            <!--        </div>-->
        </div>
    </div>

    <!-- å¼•å…¥Cherry Markdownçš„JSæ–‡ä»¶ -->
    <script src="/pc/static/js/layui.js"></script>
    <!-- <script src="/pc/static/js/echarts.js"></script> -->
    <script src="/pc/static/cherry-markdown/cherry-markdown.js"></script>
    <script src="/pc/static/js/mermaid.js"></script>
    <script src="/pc/static/js/jquery-2.1.1.js"></script>
    <script src="/pc/static/js/request.js"></script>
    <!-- <script src="https://unpkg.com/mermaid@10/dist/mermaid.min.js"></script> -->


    <script>
        // let doc_name = ""
        // let keywords = ""
        // let menu = ""
        // let content = ''
        // let selection = ''
        // let start_pos = { line: 0, ch: 0 }
        // let end_pos = { line: 0, ch: 0 }
        // let editor
        // let headings = [];
        // // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–ç¼–è¾‘å™¨
        // window.onload = function () {
        //     editor = new Cherry({
        //         id: 'editor',            // ç»‘å®šå®¹å™¨çš„ID
        //         width: '100%',           // ç¼–è¾‘å™¨å®½åº¦
        //         height: '90%',          // ç¼–è¾‘å™¨é«˜åº¦
        //         markdown: 'asdasdasd' // åˆå§‹markdownæ–‡æœ¬
        //         // å¯æ ¹æ®éœ€æ±‚æ·»åŠ å…¶ä»–é…ç½®é¡¹
        //     });


        //     // ç›‘å¬ CodeMirror çš„ paste äº‹ä»¶
        //     let cm = editor.getCodeMirror();

        let doc_name = ""
        let keywords = ""
        let menu = ""
        let content = ''
        let selection = ''
        let start_pos = { line: 0, ch: 0 }
        let end_pos = { line: 0, ch: 0 }
        let editor
        let headings = [];

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–ç¼–è¾‘å™¨
        window.onload = function () {
            mermaid.initialize({
                flowchart: { htmlLabels: false },
                startOnLoad: false,
                useMaxWidth: false,  // å…¨å±€ç¦ç”¨å“åº”å¼å®½åº¦ï¼Œä½¿ç”¨å›ºå®šåƒç´ å¤§å°
                // flowchart: { useMaxWidth: false },  // é’ˆå¯¹æµç¨‹å›¾
                // sequence: { useMaxWidth: false },   // é’ˆå¯¹åºåˆ—å›¾
                // gantt: { useMaxWidth: false },      // é’ˆå¯¹ç”˜ç‰¹å›¾ï¼ˆå¯é€‰ï¼Œæ ¹æ®æ‚¨çš„å›¾è¡¨ç±»å‹æ·»åŠ ï¼‰
                // å¯ä»¥æ·»åŠ æ›´å¤šç±»å‹ï¼Œå¦‚ classDiagram: { useMaxWidth: false }
            });

            editor = new Cherry({
                id: 'editor',            // ç»‘å®šå®¹å™¨çš„ID
                width: '100%',           // ç¼–è¾‘å™¨å®½åº¦
                height: '90%',           // ç¼–è¾‘å™¨é«˜åº¦
                markdown: 'asdasdasd', // åˆå§‹markdownæ–‡æœ¬
                callback: {
                    afterChange: function () {
                        addPreviewTitle();
                    },
                    afterRender: function () {
                        addPreviewTitle();
                    }
                }
            });

            function setPerviewerCss() {
                const parent = document.querySelector('.cherry-previewer');
                const children = parent.querySelectorAll(':not(:first-child)');

                children.forEach(el => {
                    el.style.backgroundColor = '#f0f0f0';
                    el.style.border = '1px solid #ccc';
                });

            }

            function addPreviewTitle() {
                const previewerEl = document.querySelector('.cherry-previewer');
                if (previewerEl && !previewerEl.querySelector('.preview-title')) {
                    const previewTitle = document.createElement('div');
                    previewTitle.className = 'cherry-editor-title preview-title';
                    previewTitle.innerText = 'é¢„è§ˆåŒº';
                    previewTitle.style = 'margin: -20px 0px 20px -20px; width: calc(100% + 20px);'
                    previewerEl.prepend(previewTitle);
                }
            }

            // è·å– CodeMirror å®ä¾‹
            let cm = editor.getCodeMirror();
            // è·å–ç¼–è¾‘åŒº DOM
            const editWrapper = cm.getWrapperElement();

            // æ·»åŠ ç¼–è¾‘åŒºæ ‡é¢˜
            const editTitle = document.createElement('div');
            editTitle.className = 'cherry-editor-title';
            editTitle.innerText = 'ç¼–è¾‘åŒº';
            const Tip = document.createElement('div');
            Tip.className = 'tip';
            Tip.innerText = 'å¯å°†å¤§æ¨¡å‹ä¸­çš„å†…å®¹å¤åˆ¶åˆ°æ­¤å¤„è¿›è¡Œç¼–è¾‘';
            editTitle.prepend(Tip)
            editWrapper.appendChild(editTitle);


            // ---------- å³é”®èœå•åŠŸèƒ½ ----------
            const showContextMenu = (e, items) => {
                e.preventDefault();
                $('.custom-popup').remove();
                const $menu = $('<div class="custom-popup"></div>').css({
                    top: e.pageY + 'px',
                    left: e.pageX + 'px',
                    position: 'absolute',
                    zIndex: 9999,
                    background: '#fff',
                    border: '1px solid #ccc',
                    padding: '5px',
                    minWidth: '120px',
                    borderRadius: '4px',
                    boxShadow: '0 2px 6px rgba(0,0,0,0.2)'
                });

                Object.entries(items).forEach(([label, handler]) => {
                    const $item = $('<div class="menu-item"></div>').text(label).css({
                        padding: '8px 12px',
                        cursor: 'pointer'
                    });
                    $item.on('click', function () {
                        handler();
                        $('.custom-popup').remove();
                    });
                    $item.hover(() => $item.css('background', '#f2f2f2'),
                        () => $item.css('background', '#fff'));
                    $menu.append($item);
                });

                $('body').append($menu);
            };

            // ç‚¹å‡»é¡µé¢å…¶å®ƒåœ°æ–¹æ—¶éšè—èœå•
            $(document).on('click', () => $('.custom-popup').remove());

            // ç»‘å®šå³é”®äº‹ä»¶åˆ°ç¼–è¾‘å™¨
            cm.getWrapperElement().addEventListener("contextmenu", function (e) {
                e.preventDefault();
                const selectedText = cm.getSelection();
                showContextMenu(e, {
                    'å¤åˆ¶': () => {
                        if (selectedText) {
                            navigator.clipboard.writeText(selectedText).then(() => {
                                layer.msg('å¤åˆ¶æˆåŠŸ', { icon: 1, time: 1000 });
                            });
                        } else {
                            layer.msg('è¯·å…ˆé€‰ä¸­è¦å¤åˆ¶çš„å†…å®¹', { icon: 0, time: 1500 });
                        }
                    },
                    'ç²˜è´´': async () => {
                        $.ajax({
                            url: '/api/md/mdPaste',
                            type: 'POST',
                            contentType: 'application/json; charset=utf-8',
                            success: function (result) {
                                if (result.success) {
                                    cm.replaceSelection(result.data);
                                }
                            },
                            error: function (xhr, status, err) {
                                console.error("è¯·æ±‚é”™è¯¯:", err);
                            }
                        });
                    }
                });
            });


            cm.on("paste", function (cm, e) {
                e.preventDefault();
                const clipboardData = e.clipboardData || window.clipboardData;
                let pastedText = clipboardData.getData('text');
                const unixFormattedText = pastedText.replace(/\r\n/g, '\n');

                // åœ¨å…‰æ ‡ä½ç½®æ’å…¥æ–‡æœ¬
                cm.replaceSelection(unixFormattedText);
            });


        };

        // å¾ªç¯ç›‘å¬é¢„è§ˆåŒº DOM æ˜¯å¦ç”Ÿæˆ
        const previewCheckInterval = setInterval(() => {
            let previewerEl = null;

            previewerEl = document.querySelector('.cherry-previewer');
            if (previewerEl) {
                // ç”Ÿæˆæ ‡é¢˜
                const previewTitle = document.createElement('div');
                previewTitle.className = 'cherry-editor-title';
                previewTitle.innerText = 'é¢„è§ˆåŒº';
                previewTitle.style = 'margin: -20px 0px 20px -20px; width: calc(100% + 20px);'
                previewerEl.appendChild(previewTitle);

                // åœæ­¢å¾ªç¯
                clearInterval(previewCheckInterval);
            }
        }, 50);

        async function mermaidToBase64(mermaidCode) {
            return new Promise(async (resolve) => {
                try {
                    const renderId = 'tempMermaid_' + Date.now() + Math.random().toString(36).slice(2);
                    const { svg: svgCode } = await mermaid.render(renderId, mermaidCode);
                    if (!svgCode) return resolve(null);

                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgCode, 'image/svg+xml');
                    const svgEl = doc.querySelector('svg');
                    if (!svgEl) return resolve(null);
                    svgEl.setAttribute('style', 'overflow: visible;');
                    let width = parseFloat(svgEl.getAttribute('width'));
                    let height = parseFloat(svgEl.getAttribute('height'));

                    if ((!width || !height) && svgEl.getAttribute('viewBox')) {
                        const viewBox = svgEl.getAttribute('viewBox').split(/\s+/);
                        width = parseFloat(viewBox[2]);
                        height = parseFloat(viewBox[3]);
                    }

                    // é»˜è®¤æœ€å°å®½é«˜
                    width = width || 800;
                    height = height || 600;

                    const svgData = new XMLSerializer().serializeToString(svgEl);
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');

                    const img = new Image();
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL('image/png'));
                    };
                    img.onerror = () => resolve(null);
                    img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgData);
                } catch (err) {
                    console.error('Mermaid æ¸²æŸ“é”™è¯¯:', err);
                    resolve(null);
                }
            });
        }

        function svgToPngBase64(svgElement) {
            const svgStr = new XMLSerializer().serializeToString(svgElement);
            const canvas = document.createElement("canvas");
            const bbox = svgElement.getBoundingClientRect();
            canvas.width = bbox.width || 800;
            canvas.height = bbox.height || 600;
            const ctx = canvas.getContext("2d");

            const img = new Image();

            return new Promise(resolve => {
                img.onload = () => {
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL('image/png'));
                    };
                    img.onerror = () => resolve(null);
                    img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgStr);
            });
        }

        async function replaceSvgWithPng(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, "text/html");
            const svgs = Array.from(doc.querySelectorAll("svg"));

            for (let svg of svgs) {
                const pngBase64 = await svgToPngBase64(svg);
                const img = doc.createElement("img");
                img.src = pngBase64;
                svg.parentNode.replaceChild(img, svg);
            }

            return doc.body.innerHTML;
        }


        async function export_pdf(type) {
            var md_content = editor.getMarkdown().trim();
            var html_content = editor.getHtml();
            if (md_content == '') {
                layui.use(function () {
                    var layer = layui.layer;
                    layer.msg('è¯·å…ˆç¼–è¾‘å†…å®¹');
                    return;
                })
            } else {
                var layerIndex = layer.load(2, { shade: [0.5, '#000'] });
                var replace_html_content = await replaceSvgWithPng(html_content);
                $.ajax({
                    url: '/api/md/mdPdf',
                    type: 'POST',
                    data: JSON.stringify({ html_content: replace_html_content }),
                    contentType: 'application/json; charset=utf-8',
                    success: function (result) {
                        if (result.success) {
                            // æŠŠ Base64 è½¬æˆ Blob
                            const byteCharacters = atob(result.file);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray], { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });
                            // åˆ›å»ºä¸‹è½½é“¾æ¥
                            const link = document.createElement("a");
                            link.href = window.URL.createObjectURL(blob);
                            // æ‰¾åˆ°ç¬¬ä¸€è¡Œéç©ºæ–‡æœ¬
                            let firstLine = md_content.split('\n').find(line => line.trim() !== '') || 'markdown';
                            // å»æ‰ Markdown æ ‡è®°ï¼ˆå¦‚ #ã€*ã€_ ç­‰ï¼‰
                            firstLine = firstLine.replace(/^#+\s*/, '').replace(/[*_`~>]/g, '').trim();
                            // å–å‰ 10 ä¸ªå­—ç¬¦ï¼ˆé¿å…å¤ªé•¿ï¼‰
                            firstLine = firstLine.slice(0, 10) || 'markdown';
                            link.download = `${firstLine}.pdf`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            window.URL.revokeObjectURL(link.href);
                            layer.close(layerIndex);
                            layer.msg('å¯¼å‡ºæˆåŠŸ');
                        }
                    },
                    error: function (xhr, status, err) {
                        layer.close(layerIndex);
                        layer.msg('å¯¼å‡ºå¤±è´¥');
                        console.error("è¯·æ±‚é”™è¯¯:", err);
                    }

                });
            }
        }

        //å¤åˆ¶ä¸ºmarkdown
        async function export_markdown() {
            var md_content = editor.getMarkdown().trim();
            if (md_content == '') {
                layui.use(function () {
                    var layer = layui.layer;
                    layer.msg('è¯·å…ˆç¼–è¾‘å†…å®¹');
                    return;
                })
            } else {
                 var layerIndex = layer.load(2, { shade: [0.5, '#000'] });

                $.ajax({
                    url: '/api/md/mdFile',
                    type: 'POST',
                    data: JSON.stringify({ md_content: md_content }),
                    contentType: 'application/json; charset=utf-8',
                    success: function (result) {
                        if (result.success) {
                            // æŠŠ Base64 è½¬æˆ Blob
                            const byteCharacters = atob(result.file);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray], { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });
                            // åˆ›å»ºä¸‹è½½é“¾æ¥
                            const link = document.createElement("a");
                            link.href = window.URL.createObjectURL(blob);
                            // æ‰¾åˆ°ç¬¬ä¸€è¡Œéç©ºæ–‡æœ¬
                            let firstLine = md_content.split('\n').find(line => line.trim() !== '') || 'markdown';
                            // å»æ‰ Markdown æ ‡è®°ï¼ˆå¦‚ #ã€*ã€_ ç­‰ï¼‰
                            firstLine = firstLine.replace(/^#+\s*/, '').replace(/[*_`~>]/g, '').trim();
                            // å–å‰ 10 ä¸ªå­—ç¬¦ï¼ˆé¿å…å¤ªé•¿ï¼‰
                            firstLine = firstLine.slice(0, 10) || 'markdown';
                            link.download = `${firstLine}.md`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            window.URL.revokeObjectURL(link.href);
                            layer.close(layerIndex);
                            layer.msg('å¯¼å‡ºæˆåŠŸ');
                        }
                    },
                    error: function (xhr, status, err) {
                        layer.close(layerIndex);
                        layer.msg('å¯¼å‡ºå¤±è´¥');
                        console.error("è¯·æ±‚é”™è¯¯:", err);
                    }

                });
            }
        }




        //å¤åˆ¶ä¸ºæ–‡æœ¬
        function export_txt() {
            var text = editor.getMarkdown().trim();
            if (!text) {
                layer.msg("è¯·å…ˆç¼–è¾‘å†…å®¹")
                return
            };
            // ä½¿ç”¨ Clipboard API
            navigator.clipboard.writeText(text).then(() => {
                layer.msg("å¤åˆ¶æ–‡æœ¬æˆåŠŸ")
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥:', err);
            });
        }

        async function export_word(type) {
            var md_content = editor.getMarkdown().trim();
            if (md_content == '') {
                layui.use(function () {
                    var layer = layui.layer;
                    layer.msg('è¯·å…ˆç¼–è¾‘å†…å®¹');
                    return;
                })
            } else {
                var layerIndex = layer.load(2, { shade: [0.5, '#000'] });
                // æ›¿æ¢ Mermaid ä»£ç å—
                const mermaidRegex = /```mermaid\n([\s\S]*?)```/g;
                md_content = md_content.replace(/<br\s*\/?>/gi, '\\n');
                const promises = [];
                let match;
                while ((match = mermaidRegex.exec(md_content)) !== null) {
                    const code = match[1];
                    promises.push(mermaidToBase64(code));
                }
                const base64Images = await Promise.all(promises);
                // æ›¿æ¢ Markdown ä¸­ Mermaid ä¸º Base64 å›¾ç‰‡
                let index = 0;
                md_content = md_content.replace(mermaidRegex, () => {
                    const img = base64Images[index++];
                    return img ? `![](${img})` : '';
                });

                // console.log('å¤„ç†åçš„ Markdown:', markdown);
                $.ajax({
                    url: '/api/md/mdWord',
                    type: 'POST',
                    data: JSON.stringify({ md_content: md_content }),
                    contentType: 'application/json; charset=utf-8',
                    success: function (result) {
                        if (result.success) {
                            // æŠŠ Base64 è½¬æˆ Blob
                            const byteCharacters = atob(result.file);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray], { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });
                            // åˆ›å»ºä¸‹è½½é“¾æ¥
                            const link = document.createElement("a");
                            link.href = window.URL.createObjectURL(blob);
                            // æ‰¾åˆ°ç¬¬ä¸€è¡Œéç©ºæ–‡æœ¬
                            let firstLine = md_content.split('\n').find(line => line.trim() !== '') || 'markdown';
                            // å»æ‰ Markdown æ ‡è®°ï¼ˆå¦‚ #ã€*ã€_ ç­‰ï¼‰
                            firstLine = firstLine.replace(/^#+\s*/, '').replace(/[*_`~>]/g, '').trim();
                            // å–å‰ 10 ä¸ªå­—ç¬¦ï¼ˆé¿å…å¤ªé•¿ï¼‰
                            firstLine = firstLine.slice(0, 10) || 'markdown';
                            link.download = `${firstLine}.docx`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            window.URL.revokeObjectURL(link.href);
                            layer.close(layerIndex);
                            layer.msg('å¯¼å‡ºæˆåŠŸ');
                        }
                    },
                    error: function (xhr, status, err) {
                        layer.close(layerIndex);
                        layer.msg('å¯¼å‡ºå¤±è´¥');
                        console.error("è¯·æ±‚é”™è¯¯:", err);
                    }

                });
            }
        }

        function startUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                alert('è¯·å…ˆé€‰æ‹©æ–‡ä»¶');
                return;
            }

            // åˆ†ç‰‡é…ç½®ï¼ˆ1MBï¼‰
            const chunkSize = 1024 * 1024;
            const totalChunks = Math.ceil(file.size / chunkSize);

            // è§£ææ–‡ä»¶åå’Œæ‰©å±•å
            const lastDotIndex = file.name.lastIndexOf('.');
            const fileName = lastDotIndex > 0 ? file.name.substring(0, lastDotIndex) : file.name;
            const fileExt = lastDotIndex > 0 ? file.name.substring(lastDotIndex + 1) : '';

            let currentChunk = 0;

            function uploadChunk() {
                const start = currentChunk * chunkSize;
                const end = Math.min(start + chunkSize, file.size);
                const chunk = file.slice(start, end);

                // åˆ›å»ºè¡¨å•æ•°æ®
                const formData = new FormData();
                formData.append('file', chunk, file.name);
                formData.append('fileName', fileName);
                formData.append('fileExt', fileExt);
                formData.append('page', currentChunk + 1);  // åˆ†ç‰‡ä»1å¼€å§‹è®¡æ•°
                formData.append('totalPage', totalChunks);

                const xhr = new XMLHttpRequest();
                xhr.open('POST', '/api/uploadtempfile', true);  // æ›¿æ¢ä¸ºå®é™…æ¥å£åœ°å€

                xhr.onload = function () {
                    if (xhr.status === 200) {
                        const response = JSON.parse(xhr.responseText);
                        if (response.finish === 2) {
                            alert('æ–‡ä»¶ä¸Šä¼ å®Œæˆï¼');
                            doc_name = response.obj
                        } else {
                            currentChunk++;
                            if (currentChunk < totalChunks) {
                                uploadChunk();  // ç»§ç»­ä¸Šä¼ ä¸‹ä¸€åˆ†ç‰‡
                            }
                        }


                    } else {
                        console.error(`ä¸Šä¼ å¤±è´¥: ${xhr.statusText}`);
                    }
                };

                xhr.onerror = function () {
                    console.error('ç½‘ç»œé”™è¯¯ï¼Œä¸Šä¼ å¤±è´¥');
                };

                xhr.send(formData);
            }

            uploadChunk();  // å¼€å§‹ä¸Šä¼ ç¬¬ä¸€ä¸ªåˆ†ç‰‡
        }

        function generateMenu() {
            if (doc_name === "") {
                alert("å…ˆä¸Šä¼ æ–‡ä»¶")
            }
            const formData = new FormData()
            formData.append('file_name', doc_name);
            formData.append('prompt', 'menu');
            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/api/generateMsg', true);  // æ›¿æ¢ä¸ºå®é™…æ¥å£åœ°å€
            xhr.onload = function () {
                if (xhr.status === 200) {
                    const response = JSON.parse(xhr.responseText);
                    editor.setMarkdown(response.obj)
                    keywords = response.keywords
                    menu = response.obj
                    parseMarkdown(response.obj)
                }
            }
            xhr.send(formData);
        }

        async function generateMsg(i) {
            console.log(headings)
            if (i === headings.length) {
                alert('å†…å®¹ç”Ÿæˆå®Œæˆï¼');
            } else {
                let heading = headings[i]
                let head = heading['heading']
                let start = heading['contentLine']['start']
                let end = heading['contentLine']['end']

                const formData = new FormData()
                formData.append('file_name', doc_name);
                formData.append('menus', menu);
                formData.append('keywords', keywords);
                formData.append('menu_name', head);
                formData.append('prompt', 'text');

                try {
                    const response = await fetch('/api/generateMsg', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        const data = await response.json();
                        let cm = editor.getCodeMirror();
                        cm.replaceRange(data.obj + '\n\n', { line: start, ch: 0 }, { line: end, ch: 0 });
                        parseMarkdown(editor.getMarkdown());
                        editor.getCodeMirror().setCursor({ line: headings[i + 1]['contentLine']['end'], ch: 0 })
                        // editor.previewer.scrollToId(headings[i + 1]['heading']);
                    } else {
                        console.error(`Error on heading ${i}:`, response.status);
                    }
                } catch (error) {
                    console.error(`Exception on heading ${i}:`, error);
                }
                await generateMsg(i + 1)
            }
        }

        function parseMarkdown(markdown) {
            headings = []

            // 1. åˆå§‹åŒ–è§£æå™¨ï¼ˆå¯ç”¨è¡Œå·è¿½è¸ªï¼‰
            const md = window.markdownit({
                source: true,   // ä¿ç•™è¡Œå·ä¿¡æ¯
                html: false,    // ç¦ç”¨ HTML æ ‡ç­¾è§£æ
                breaks: true
            });

            // è§£æ Markdown æ–‡æœ¬
            const tokens = md.parse(markdown, {});

            // éå† tokensï¼ŒæŸ¥æ‰¾æ ‡é¢˜åŠå…¶å¯¹åº”å†…å®¹çš„è¡Œå·
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].type === 'heading_open') {
                    const headingToken = tokens[i];
                    const inlineToken = tokens[i + 1]; // ç´§è·Ÿçš„ inline token åŒ…å«æ ‡é¢˜æ–‡å­—
                    // æ ‡é¢˜æ‰€åœ¨çš„è¡Œå·ï¼ˆmap æ•°ç»„ï¼š [startLine, endLine]ï¼‰
                    const headingStartLine = headingToken.map ? headingToken.map[0] + 1 : null; // +1 è½¬æ¢ä¸º 1 åŸºå‡†
                    const headingEndLine = headingToken.map ? headingToken.map[1] : null;

                    // å®šä¹‰å†…å®¹å¼€å§‹è¡Œï¼šæ ‡é¢˜ç»“æŸè¡Œçš„ä¸‹ä¸€è¡Œ
                    let contentStartLine = headingToken.map ? headingToken.map[1] + 1 : null;
                    let contentEndLine = null;

                    // å¯»æ‰¾ä¸‹ä¸€ä¸ªæ ‡é¢˜ token ä»¥ç¡®å®šæœ¬æ ‡é¢˜çš„å†…å®¹ç»“æŸè¡Œ
                    let j = i + 1;
                    while (j < tokens.length) {
                        if (tokens[j].type === 'heading_open') {
                            if (tokens[j].map) {
                                contentEndLine = tokens[j].map[0]; // ä¸‹ä¸€ä¸ªæ ‡é¢˜å¼€å§‹çš„è¡Œä½œä¸ºç»“æŸè¡Œ
                            }
                            break;
                        }
                        j++;
                    }
                    // å¦‚æœåé¢æ²¡æœ‰æ›´å¤šæ ‡é¢˜ï¼Œåˆ™å†…å®¹å»¶ç»­åˆ°æ–‡æ¡£æœ€åä¸€è¡Œ
                    if (contentEndLine === null) {
                        // å‡è®¾æœ€åä¸€ä¸ª token çš„ map çš„ç»“æŸè¡Œå°±æ˜¯æ–‡æ¡£æ€»è¡Œæ•°
                        const lastToken = tokens[tokens.length - 1];
                        contentEndLine = lastToken.map ? lastToken.map[1] : contentStartLine;
                    }

                    headings.push({
                        heading: inlineToken ? inlineToken.content : '',
                        headingLine: {
                            start: headingStartLine,
                            end: headingEndLine
                        },
                        contentLine: {
                            start: contentStartLine,
                            end: contentEndLine
                        }
                    });
                }
            }

        }

        // è¾…åŠ©å‡½æ•°ï¼šè·å–æ ‡é¢˜æ–‡æœ¬
        function getHeadingText(tokens, index) {
            let i = index + 1;
            let text = '';
            while (tokens[i]?.type !== 'heading_close') {
                if (tokens[i]?.type === 'inline') {
                    text += tokens[i].content;
                }
                i++;
            }
            return text.trim();
        }

        // è¾…åŠ©å‡½æ•°ï¼šè·å–åˆ—è¡¨é¡¹æ–‡æœ¬
        function getListItemText(tokens, index) {
            let i = index + 1;
            let text = '';
            while (tokens[i]?.type !== 'list_item_close') {
                if (tokens[i]?.type === 'inline') {
                    text += tokens[i].content;
                }
                i++;
            }
            return text.trim();
        }


        let eventSource = null;
        let currentMessageId = null;

        // åˆå§‹åŒ–SSEè¿æ¥
        function initSSE() {
            if (eventSource) eventSource.close();

            eventSource = new EventSource('/api/sse');

            eventSource.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.id !== currentMessageId) return;


                if (data.type === 'start') {
                    content = ''
                    appendMessage('', 'ai', true);
                } else if (data.type === 'delta') {
                    content += data.content
                    appendDeltaContent(data.content);
                } else if (data.type === 'end') {
                    finalizeMessage(content);
                }
            };

            eventSource.onerror = () => {
                console.error('SSEè¿æ¥é”™è¯¯');
                eventSource.close();
            };
        }

        async function send(param) {
            try {
                const response = await fetch('/api/bsChat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: param
                });

                if (!response.ok) {
                    throw new Error('è¯·æ±‚å¤±è´¥');
                }
            } catch (error) {
                console.error('å‘é€å¤±è´¥:', error);
                appendMessage("æ¶ˆæ¯å‘é€å¤±è´¥", 'ai');
            }
        }

        // å®Œæˆæ¶ˆæ¯å¤„ç†
        function finalizeMessage(content) {
            let messageEl = document.querySelector('.last-message');
            messageEl.classList.remove('last-message');
            currentMessageId = null;
            const actionBar = document.createElement('div');
            actionBar.className = 'message-actions';
            actionBar.innerHTML = '<button class="replace-bubble" onclick="handleReplace(`' + content + '`)">æ›¿æ¢é€‰ä¸­æ–‡å­—</button>';
            messageEl.appendChild(actionBar);
        }

        function handleReplace(content) {
            let cm = editor.getCodeMirror();
            cm.replaceRange(content + '\n\n', start_pos, end_pos);
        }

        // åˆå§‹åŒ–æ—¶å»ºç«‹è¿æ¥
        // initSSE();

    </script>

</body>

</html>